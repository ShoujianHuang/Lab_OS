练习1: 加载应用程序并执行（需要编码）
do_execv函数调用load_icode(位于kern/process/proc.c中)来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。

请简要描述这个用户态进程被ucore选择占用CPU执行(RUNNING态)到具体执行应用程序第一条指令的整个经过。
进程调度：当ucore的调度器选择一个用户态进程来执行时，它会根据调度算法从就绪队列中选择一个进程，并将其状态设置为RUNNING态。这意味着该进程将获得CPU的执行权。

上下文切换：在ucore中，当一个进程从等待态或就绪态切换到运行态时，需要进行上下文切换。这包括保存前一个进程的上下文信息（包括CPU寄存器、程序计数器等）到内存中，并加载将要执行的进程的上下文信息到CPU寄存器中。

用户态进程执行：一旦用户态进程的上下文信息被加载到CPU寄存器中，CPU开始执行用户态进程的代码。在执行过程中，用户态进程的代码和数据会通过虚拟内存系统进行访问，可能会触发页表的加载、TLB的刷新等操作。

执行应用程序的第一条指令：最终，CPU将开始执行用户态进程的代码。在执行过程中，用户态进程的代码和数据会通过虚拟内存系统进行访问，可能会触发页表的加载、TLB的刷新等操作。当执行到应用程序的第一条指令时，应用程序开始正式运行。

 tf->gpr.sp = USTACKTOP;// 设置用户进程的栈指针为用户栈的顶部.当进程从内核态切换到用户态时，栈指针需要指向用户栈的有效地址
    tf->epc = elf->e_entry; //修改epc，sret返回地址发生变化，返回执行exit.c函数，其中执行退出，调用sys_exit
    // 进程从内核态切换到用户态，需要将中断帧的状态调整为用户态，清除了 SPP 表示的特权级信息，以及 SPIE 表示的中断使能信息。
    tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);// 将 sstatus 寄存器中的 SPP和 SPIE位清零





练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程(即父进程)的用户内存地址空间中的合法内容到新进程中(子进程),完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

如何设计实现Copy on Write机制?给出概要设计,鼓励给出详细设计。


内存页表的修改：首先，操作系统需要修改内存页表的数据结构，以支持Copy on Write。在页表中，可以为每个内存页添加一个标志位，用来表示该页是否处于Copy on Write状态。
内存页的复制：当一个进程试图修改一个共享的内存页时，操作系统会检查该内存页的标志位。如果该内存页处于Copy on Write状态，操作系统会先复制该内存页，然后再将新的内存页分配给该进程进行修改。这样可以保持原始内存页的完整性，同时允许进程进行修改。
内存页的共享：在初始状态下，多个进程可以共享相同的内存页。只有当一个进程试图修改该内存页时，才会触发Copy on Write机制，进行内存页的复制。这样可以避免不必要的内存复制，提高了内存的使用效率。

 void* src_kvaddr = page2kva(page); // 源页的内核虚拟地址
            void* dst_kvaddr = page2kva(npage); // 目标页的内核虚拟地址
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE); // 复制页面内容
            ret = page_insert(to, npage, start, perm); // 建立映射






练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：

请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？

fork操作：
用户态：父进程调用fork系统调用，创建一个与父进程几乎完全相同的子进程。在用户态，fork系统调用会将父进程的地址空间复制到子进程中，包括代码段、数据段、堆栈等。
内核态：在内核态，操作系统会为子进程分配资源，包括分配进程控制块（PCB）、复制父进程的地址空间、设置子进程的状态等。这些操作需要在内核态完成。

exec操作：
用户态：进程调用exec系统调用来加载并执行一个新的程序，替换当前进程的地址空间和代码段。
内核态：在内核态，操作系统会加载新的程序映像到进程的地址空间中，设置新的程序入口点、堆栈、数据段等，并将控制权交给新的程序。这些操作需要在内核态完成。

wait操作：
用户态：父进程调用wait系统调用，等待子进程结束并获取子进程的退出状态。
内核态：在内核态，操作系统会监控子进程的状态，并在子进程结束后将退出状态返回给父进程。这些操作需要在内核态完成。

exit操作：
用户态：进程调用exit系统调用，通知操作系统进程即将结束。
内核态：在内核态，操作系统会回收进程占用的资源，释放进程控制块、内存等，并通知父进程或者监管进程子进程的退出状态。这些操作需要在内核态完成。
在这些操作中，用户态程序通过系统调用进入内核态执行相应的操作。内核态与用户态程序的交错执行是通过系统调用实现的。当用户态程序发起系统调用时，操作系统会将进程从用户态切换到内核态，执行相应的操作，然后再将进程从内核态切换回用户态继续执行。这种交错执行是通过特权级别切换和中断处理来实现的。

内核态执行结果通常是通过系统调用的返回值返回给用户程序。例如，fork系统调用在父进程中返回子进程的进程ID，exec系统调用在成功执行时不返回，wait系统调用返回子进程的退出状态等。这些返回值可以通过系统调用的返回值或者通过指定的参数传递给用户程序。



请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
+------------------+        +------------------+        +------------------+
|     Create       | -----> |      Ready       | -----> |     Running      |
+------------------+        +------------------+        +------------------+
      |  创建进程              |  调度器分配CPU资源         |  进程时间片用完 /
      |                       |  或者等待I/O完成           |  进程主动让出CPU
      |                       |                           |  或者被抢占
      V                       V                           V
+------------------+        +------------------+        +------------------+
|     Exit         | <----- |     Blocked      | <----- |     Running      |
+------------------+        +------------------+        +------------------+
      |  进程执行完毕          |  I/O操作等待完成            |  I/O操作开始
      V                       |                           |
+------------------+        |                           |
|     Exit         |        |                           |
+------------------+        +---------------------------+

创建状态（Create）：进程被创建，但还未开始执行。
就绪状态（Ready）：进程已经准备好运行，等待调度器分配CPU资源。
运行状态（Running）：进程正在执行指令，占用CPU资源。
阻塞状态（Blocked）：进程由于某些事件发生而无法继续执行，例如等待I/O操作完成。
结束状态（Exit）：进程执行完毕，等待被回收。

产生状态变换的事件如下：
进程被创建时，产生初始状态。
当进程等待CPU资源时，产生就绪状态。
当进程获得CPU资源时，产生运行状态。
当进程等待I/O操作完成时，产生阻塞状态。
当进程完成任务时，产生结束状态。
